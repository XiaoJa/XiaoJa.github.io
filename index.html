<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JUC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/23/JUC/" class="article-date">
  <time class="dt-published" datetime="2024-07-23T02:24:01.000Z" itemprop="datePublished">2024-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/23/JUC/">JUC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="什么是JUC？"><a href="#什么是JUC？" class="headerlink" title="什么是JUC？"></a>什么是JUC？</h3><p>JUC就是java.util .concurrent工具包的简称</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程：一个程序、程序的集合，比如QQ.exe。一个进程有多个线程。</p>
<p>java默认两个线程：main、GC</p>
<p>java真的可以开启线程吗？不能，因为底层的start()是native，调用c方法完成的。</p>
<h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发：</p>
<p>多个线程操作同一个资源，比如CPU一核，线程交替执行</p>
<p>并行：</p>
<p>多个线程同时执行，比如CPU多核，线程池。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/23/JUC/" data-id="clyxstfc1000044utbvype7rh" data-title="JUC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rabbitMq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/22/rabbitMq/" class="article-date">
  <time class="dt-published" datetime="2024-07-22T14:34:49.766Z" itemprop="datePublished">2024-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这是rabbit mQ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/22/rabbitMq/" data-id="clyxstfc8000544ut8a45d3x4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/22/redis%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-22T14:34:31.505Z" itemprop="datePublished">2024-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这是redis</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/22/redis%E6%95%99%E7%A8%8B/" data-id="clyxstfc9000644uta8gm83gc" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/23/JVM/" class="article-date">
  <time class="dt-published" datetime="2022-07-23T01:56:22.000Z" itemprop="datePublished">2022-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/23/JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>栈：存放八大基本类型+对象引用+实例的方法</p>
<p>堆：存放对象实例</p>
<p>程序计数器：记录着当前线程所执行的字节码的行号指示器。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</p>
<p>方法区：存放类信息（构造方法、接口）、常量、静态变量，即static、final、Class、常量池</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>类加载时，会将请求向上委托直到启动类加载器，启动类加载器检查是否可以加载，可以就加载，不可以就交给子类，重复，直到应用加载器，如果也不行，就抛出classnotfound异常。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>新生代、老年代、永久代</p>
<p>jdk8以后，永久代移除改成元空间（位置在方法区）</p>
<p>新生代里又有伊甸园区，from幸存区，to幸存区</p>
<p>垃圾回收主要是堆内存中的伊甸园区和老年代</p>
<h3 id="OOM：内存溢出"><a href="#OOM：内存溢出" class="headerlink" title="OOM：内存溢出"></a>OOM：内存溢出</h3><p>1.尝试扩大内存查看结果</p>
<p>2.分析结果，查看哪里出现问题</p>
<p>使用Jprofiler分析：</p>
<ul>
<li>可以分析Dump内存文件、快速定位内存泄漏</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
</ul>
<h3 id="JVM-有哪些垃圾回收算法？"><a href="#JVM-有哪些垃圾回收算法？" class="headerlink" title="JVM 有哪些垃圾回收算法？"></a>JVM 有哪些垃圾回收算法？</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><strong>标记-清除算法</strong></h4><p>标记出可以回收的对象，回收被标记的对象所占用的空间。</p>
<p>优点：实现简单，不需要对象进行移动。</p>
<p>缺点：效率不高，无法清除垃圾碎片。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h4><p>按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。</p>
<p>优点：不用考虑内存碎片。</p>
<p>缺点：内存使用率不高，只有原来的一半。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><strong>标记-整理算法</strong></h4><p>标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率</p>
<h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a><strong>分代算法</strong></h4><p>对新生代基本采用复制算法，老年代采用标记整理算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/23/JVM/" data-id="clyxstfc4000144ut4uxo4htq" data-title="JVM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mysql索引" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/23/mysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="dt-published" datetime="2022-07-23T01:56:22.000Z" itemprop="datePublished">2022-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/23/mysql%E7%B4%A2%E5%BC%95/">mysql索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>​	索引是mysql为了实现针对某个字段来进行快速查找的一种数据结构，其一般由以下几种数据结构组成</p>
<p>​	B+树，Hash，全文索引，空间数据索引，通过特定的算法，将数据与这些据索引上对应的位置进行关联，从而做到当我们需要查找某些数据的时候，不需要翻遍整张表，而只需要借助我们建立的索引就知道了。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>　创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</li>
<li>　索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达	到上限值</li>
<li>　当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</li>
</ol>
<h2 id="索引使用的条件"><a href="#索引使用的条件" class="headerlink" title="索引使用的条件"></a>索引使用的条件</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用<strong>分区技术</strong>。</li>
</ul>
<h2 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h2><ul>
<li>对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，</li>
<li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li>
<li>在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li>
</ul>
<h2 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h2><ul>
<li><p><strong>单列索引</strong></p>
<p><strong>1.1.1、普通索引：</strong></p>
<p>​	MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p>
<p><strong>1.1.2、唯一索引：</strong></p>
<p>​	索引列中的值必须是唯一的，但是允许为空值，</p>
<p><strong>1.1.3、主键索引：</strong></p>
<p>​	是一种特殊的唯一索引，不允许有空值。</p>
</li>
<li><p><strong>组合索引</strong></p>
<p>​		在表中的多个字段组合上创建的索引，只有在<strong>查询条件中使用了这些字段的左边字段时</strong>，索引才会被使用，使用组合索引时遵循<strong>最左前缀集合</strong>。这个如果还不明白，等后面举例讲解时在细说</p>
</li>
<li><p><strong>全文索引</strong></p>
<p>​		全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个大煞笔，二货 …” 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。</p>
</li>
<li><p><strong>空间索引</strong></p>
<p>​		空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。</p>
</li>
</ul>
<h2 id="常用操作语句"><a href="#常用操作语句" class="headerlink" title="常用操作语句"></a>常用操作语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">普通索引INDEX：加速查找</span><br><span class="line">    唯一索引：</span><br><span class="line">        -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）</span><br><span class="line">        -唯一索引UNIQUE:加速查找+约束（不能重复）</span><br><span class="line">    联合索引：</span><br><span class="line">        -PRIMARY KEY(id,name):联合主键索引</span><br><span class="line">        -UNIQUE(id,name):联合唯一索引</span><br><span class="line">        -INDEX(id,name):联合普通索引</span><br><span class="line">1. 创建表的时候指定索引</span><br><span class="line">    create table t1(</span><br><span class="line">    id int primary key, # primary key 默认自带索引</span><br><span class="line">    name char(10),</span><br><span class="line">    unique key(name),</span><br><span class="line">    )</span><br><span class="line">2. 创建表后再为其加上索引</span><br><span class="line">    create table t2（</span><br><span class="line">    id int，</span><br><span class="line">    name char(5)</span><br><span class="line">    ）;</span><br><span class="line"></span><br><span class="line">    create index idx_name on t3(name);</span><br><span class="line">    alter table t3 add index idx_id(id);</span><br><span class="line">3. 删除索引</span><br><span class="line">    drop index idx_id on t3;</span><br><span class="line">    alter table t3 drop primary key;</span><br></pre></td></tr></table></figure>

<h2 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>数据结构</strong> </p>
<p>​		B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img"></p>
<p><strong>查找过程</strong></p>
<ul>
<li>​		进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针</li>
<li>​		然后递归地在指针所指向的节点进行查找。直到查找到叶子节点</li>
<li>​		然后在叶子节点上进行二分查找，找出 key 所对应的 data。</li>
<li>​		插入删除操作会破坏<strong>平衡树的平衡性</strong>，因此在进行插入删除操作之后，需要对树进行<strong>分裂、合并、旋转等操作来维护平衡性</strong>。</li>
</ul>
<h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><p><strong>B树</strong></p>
<p> 每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。</p>
<p> <img src="https://img-blog.csdn.net/20170920132504569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>B+树</strong></p>
<p> 只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。</p>
<p> <img src="https://img-blog.csdn.net/20170920132523536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>后来，在B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的        首选数据结构。 </p>
<h4 id="为什么使用B-树来作为索引的底层？"><a href="#为什么使用B-树来作为索引的底层？" class="headerlink" title="为什么使用B+树来作为索引的底层？"></a>为什么使用B+树来作为索引的底层？</h4><p>​		一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I&#x2F;O消耗，相对于内存存取，I&#x2F;O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的时间复杂度。树高度越小，I&#x2F;O次数越少。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li><p>无法用于排序与分组；</p>
</li>
<li><p>只支持精确查找，无法用于部分查找和范围查找。</p>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree</p>
</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p><strong>1. where语句中包含or时，可能会导致索引失效</strong></p>
<p>使用or并不是一定会使索引失效，你需要看or左右两边的查询列是否命中相同的索引。</p>
<p>假设USER表中的user_id列有索引，age列没有索引。</p>
<p>下面这条语句其实是命中索引的（据说是新版本的MySQL才可以，如果你使用的是老版本的MySQL，可以使用explain验证下）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> user_id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>但是这条语句是无法命中索引的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>假设age列也有索引的话，依然是无法命中索引的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>因此才有建议说，尽量避免使用or语句，可以根据情况尽量使用union all或者in来代替，这两个语句的执行效率也比or好些。</p>
<p><strong>2. where语句中索引列使用了负向查询，可能会导致索引失效</strong></p>
<p>​	负向查询包括：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</p>
<p><strong>3. 索引字段可以为null，使用is null或is not null时，可能会导致索引失效</strong></p>
<p>​	和or类似，如果是命中同一个索引是有效的，当时如果命中的补水同一个索引的话就会失效</p>
<p><strong>4. 在索引列上使用内置函数，一定会导致索引失效</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> DATE_ADD(login_time, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="operator">=</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p><strong>5.联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效</strong></p>
<p><strong>6. like通配符可能会导致索引失效</strong></p>
<p>like查询以%开头时，会导致索引失效</p>
<p>将%移到后面，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;李%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>利用覆盖索引来命中索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;%李%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>7.MySQL优化器的最终选择，不走索引</strong></p>
<p>​		如果引擎的出一个结论，即不需要索引，此时索引也会失效</p>
<p><strong>8 包含隐式的类型转化时也会出现索引失效的后果</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> name<span class="operator">=</span><span class="number">123</span></span><br><span class="line">优化</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>9. 对索引列进行运算，一定会导致索引失效</strong></p>
<p>运算如+，-，*，&#x2F;等，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> age <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>优化的话，要把运算放在值上，或者在应用程序中直接算好，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span> <span class="operator">-</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>





<p>索引覆盖和回表  </p>
<h2 id="聚簇索引的注意点有哪些？"><a href="#聚簇索引的注意点有哪些？" class="headerlink" title="聚簇索引的注意点有哪些？"></a><strong>聚簇索引的注意点有哪些？</strong></h2><p>聚簇索引表最大限度地提高了 I&#x2F;O 密集型应用的性能，但它也有以下几个限制：</p>
<ul>
<li><p>1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
<blockquote>
<p>关于这一点，可能面试官会换一个问法。例如，为什么主键需要是自增 ID ，又或者为什么主键需要带有时间性关联。</p>
</blockquote>
</li>
<li><p>2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。</p>
<blockquote>
<p>MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。</p>
</blockquote>
</li>
<li><p>3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<blockquote>
<p>当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
</blockquote>
</li>
<li><p>4、主键 ID 建议使用整型。因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。</p>
</li>
</ul>
<h1 id="msql优化"><a href="#msql优化" class="headerlink" title="msql优化"></a>msql优化</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>慢查询日志就是记录在mysql中响应时间超过阈值的语句</p>
<h2 id="mysql的瓶颈"><a href="#mysql的瓶颈" class="headerlink" title="mysql的瓶颈"></a>mysql的瓶颈</h2><ol>
<li>CPU 瓶颈：CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候</li>
<li>IO 瓶颈：磁盘I&#x2F;O瓶颈发生在装入数据远大于内存容量时</li>
<li>服务器硬件的性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态</li>
</ol>
<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><strong>作用</strong></p>
<p>​		使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈</p>
<p><strong>字段含义</strong></p>
<ol>
<li>表的读取顺序（id 字段）    <strong>id值越大优先级越高，越先被执行</strong></li>
<li>数据读取操作的操作类型（select_type 字段）</li>
<li>哪些索引可以使用（possible_keys 字段）</li>
<li>哪些索引被实际使用（keys 字段）</li>
<li>表之间的引用（ref 字段）</li>
<li>每张表有多少行被优化器查询（rows 字段）</li>
</ol>
<h2 id="优化顺序"><a href="#优化顺序" class="headerlink" title="优化顺序"></a>优化顺序</h2><ul>
<li><p>SQL语句及索引的优化</p>
</li>
<li><p>数据库表结构的优化</p>
</li>
<li><p>系统配置的优化</p>
</li>
<li><p>硬件的优化</p>
</li>
</ul>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>​	<strong>全值匹配我最爱， 最左前缀要遵守；</strong></p>
<p>​	<strong>带头大哥不能死， 中间兄弟不能断；</strong></p>
<p>​	<strong>索引列上少计算， 范围之后全失效；</strong></p>
<p>​	*<em>LIKE 百分写最右， 覆盖索引不写 <em>；</em></em></p>
<p>​	<strong>不等空值还有 OR， 索引影响要注意；</strong></p>
<p>​	<strong>VARCHAR 引号不可丢， SQL 优化有诀窍。</strong></p>
<p>一定要用两个%的话，就要用覆盖索引</p>
<h2 id="语句优化"><a href="#语句优化" class="headerlink" title="语句优化"></a>语句优化</h2><ul>
<li><p>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的	   末 尾.HAVING最后。</p>
</li>
<li><p>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
</li>
<li><p>避免在索引列上使用计算</p>
</li>
<li><p>避免在索引列上使用IS NULL和IS NOT NULL</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>只返回必要的列：最好不要使用 SELECT * 语句。</p>
</li>
<li><p>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</p>
</li>
<li><p>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</p>
</li>
</ul>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="S锁"><a href="#S锁" class="headerlink" title="S锁"></a>S锁</h3><p>如果事务T1持有了行r上的<code>S锁</code>，则其他事务可以同时持有行r的<code>S锁</code>，但是不能对行r加<code>X锁</code>。</p>
<h3 id="X锁"><a href="#X锁" class="headerlink" title="X锁"></a>X锁</h3><p>如果事务T1持有了行r上的<code>X锁</code>，则其他任何事务不能持有行r的<code>X锁</code>，必须等待T1在行r上的<code>X锁</code>释放。</p>
<p>如果事务T1在行r上保持<code>S锁</code>，则另一个事务T2对行r的锁的请求按如下方式处理：</p>
<ul>
<li>T2可以同时持有S锁</li>
<li>T2如果想在行r上获取<code>X锁</code>，必须等待其他事务对该行添加的<code>S锁</code>或<code>X锁</code>的释放。</li>
</ul>
<h3 id="锁的兼容性"><a href="#锁的兼容性" class="headerlink" title="锁的兼容性"></a>锁的兼容性</h3><p>锁的兼容矩阵如下：</p>
<table>
<thead>
<tr>
<th align="left">—</th>
<th align="center">排它锁(X)</th>
<th align="center">意向排它锁(IX)</th>
<th align="center">共享锁(S)</th>
<th align="center">意向共享锁(IS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">排它锁(X)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="left">意向排它锁(IX)</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">N</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="left">共享锁(S)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="left">意向共享锁(IS)</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">OK</td>
<td align="center">OK</td>
</tr>
</tbody></table>
<p>意向锁的主要目的是显示事务正在锁定某行或者正意图锁定某行</p>
<p><strong>当前读</strong></p>
<p>​		当前读，又叫加锁读，或者 阻塞读。这种读取操作不再是读取快照，而是读取最新版本并且加锁。<br>快照读不会添加任何锁。</p>
<p>这种情况下，引入我们常见的两种方式来解决该问题</p>
<ul>
<li><em><strong>乐观锁</strong></em>：在<code>UPDATE</code>的<code>WHERE</code>子句中加入版本号信息来确定修改是否生效</li>
<li><em><strong>悲观锁</strong></em>：在<code>UPDATE</code>执行前，<code>SELECT</code>后面加上<code>FOR UPDATE</code>来给记录加锁，保证记录在<code>UPDATE</code>前不被修改。<code>SELECT ... FOR UPDATE</code>是加上了X锁，也可以通过<code>SELECT ... LOCK IN SHARE MODE</code>加上S锁，来防止其他事务对该行的修改。</li>
</ul>
<p>无论是乐观锁还是悲观锁，<strong>使用的思想都是一致的，那就是当前读</strong>。乐观锁利用<code>当前读</code>判断是否是最新版本，悲观锁利用<code>当前读</code>锁定行。<br>但是使用乐观锁时仍然需要非常谨慎，因为RR是可重复读的，一定不能在UPDATE之前先把版本号读取出来。</p>
<h2 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>​		<strong>分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，每个表都对应三个文件，MYD数据文件，.MYI索引文件，.frm表结构文件。app读写的时候根据事先定义好的规则得到对应的表名，然后去操作它。</strong></p>
<hr>
<p><strong>垂直切分</strong></p>
<p>​		垂直切分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></p>
<ul>
<li>​		<strong>把不常用的字段单独放在一张表</strong></li>
<li>​		<strong>把text，blob（binary large object，二进制大对象）等大字段拆分出来放在附表中;</strong></li>
<li>​		<strong>经常组合查询的列放在一张表中;</strong></li>
</ul>
<p><strong>水平拆分</strong></p>
<p>​		水平切分就是指把数据库的行进行切分，分解成多个不同的表</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></p>
<ul>
<li><p><strong>通过hash来分表</strong></p>
</li>
<li><p><strong>通过取模来分表</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>1.分布式事务问题</strong><br>做了垂直分库或者水平分库以后,就必然会涉及到跨库执行SQL的问题,就会引发互联网界的老大难问题-“分布式事务”。那么要如何解决这个问题呢？<br>使用分布式事务中间件<br>使用MySQL自带的针对跨库的事务一致性方案(XA),不过性能要比单库的慢10倍左右。<br>能否避免掉跨库操作(比如将用户和商品放在同一个库中)<br><strong>2.跨库join的问题</strong><br>    分库分表后，表之间的关联操作将受到限制，就无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。<br>那么要如何解决这个问题呢？<br>简单的解决方法：<br>全局表：基础数据，所有库都拷贝一份。<br>字段冗余：把需要join的字段冗余在各个表中，这样有些字段就不用join去查询了。<br>系统层组装：应用端先分别查询出所有复核条件的，然后在应用端组装起来，类似于一个mapreduce的过程（较复杂）。<br><strong>3.横向扩容的问题</strong><br>    当我们使用哈希取模做分表的时候,针对数据量的递增,可能需要动态的增加表,此时就需要考虑数据迁移的问题。<br>原来使用的是hash后对8进行取模，那么，数据是均分在8个表(库)上。<br>如果8个表不够的时候，我们要扩展到16个表，这时候，我们hash后对16取模，新数据是没有问题的，旧数据就会发生错乱。<br>如果哈希后是9，那么，原来我们对8取模后，是1，会到表1进行查询；但是，现在我们是对16取模，那么是到表9进行查询的，而这个数据在表9又不存在，因此，就会找不到数据了<br><strong>4.结果集合并、排序的问题</strong><br>    因为我们是将数据分散存储到不同的库、表里的,当我们查询指定数据列表时,数据来源于不同的子库或者子表,就必然会引发结果集合并、排序的问题。<br>如果每次查询都需要排序、合并等操作,性能肯定会受非常大的影响。</p>
</li>
</ul>
<h3 id="分区（partition）"><a href="#分区（partition）" class="headerlink" title="分区（partition）"></a>分区（partition）</h3><p>​		分区和分表相似，都是按照规则分解表。不同在于分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，分区后，表还是一张表，但数据散列到多个位置了。app读写的时候操作的还是表名字，db自动去组织分区的数据。</p>
<p><strong>水平分区</strong></p>
<p>​		水平分区（Horizontal Partitioning） 这种形式分区是对表的行进行分区，所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</p>
<p>​		举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。		</p>
<p><strong>垂直分区</strong></p>
<p>​		垂直分区（Vertical Partitioning）这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p>
<p>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p>
<p>分区的方式</p>
<p><em><strong>*1.RANGE分区*</strong></em></p>
<p>基于属于一个给定连续区间的列值，把多行分配给分区。这些区间要连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。以下是实例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">CREATE <span class="selector-tag">TABLE</span> employees (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id INT NOT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hired DATE NOT NULL DEFAULT &#x27;<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    separated DATE NOT NULL DEFAULT &#x27;<span class="number">9999</span>-<span class="number">12</span>-<span class="number">31</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    job_code INT NOT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    store_id INT NOT NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> partition BY RANGE (store_id) (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p0 VALUES LESS THAN (<span class="number">6</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p1 VALUES LESS THAN (<span class="number">11</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p2 VALUES LESS THAN (<span class="number">16</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p3 VALUES LESS THAN (<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>按照这种分区方案，在商店1到5工作的雇员相对应的所有行被保存在分区P0中，商店6到10的雇员保存在P1中，依次类推。注意，每个分区都是按顺序进行定义，从最低到最高。<br>对于包含数据(72, ‘Michael’, ‘Widenius’, ‘1998-06-25’, NULL, 13)的一个新行，可以很容易地确定它将插入到p2分区中，但是如果增加了一个编号为第21的商店，将会发生什么呢？在这种方案下，由于没有规则把store_id大于20的商店包含在内，服务器将不知道把该行保存在何处，将会导致错误。要避免这种错误，可以创建maxvalue分区，所有不在指定范围内的记录都会被存储到maxvalue所在的分区中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter <span class="selector-tag">table</span> test2<span class="selector-class">.user</span> add partition (partition p4 values less than maxvalue);</span><br></pre></td></tr></table></figure>

<p><em><strong>*2.LIST分区*</strong></em></p>
<p>类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。<br> LIST分区通过使用“PARTITION BY LIST(expr)”来实现，其中“expr” 是某列值或一个基于某个列值、并返回一个整数值的表达式，然后通过“VALUES IN (value_list)”的方式来定义每个分区，其中“value_list”是一个通过逗号分隔的整数列表。要按照属于同一个地区商店的行保存在同一个分区中的方式来分割表，可以使用下面的“CREATE TABLE”语句：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">CREATE <span class="selector-tag">TABLE</span> employees (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id INT NOT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hired DATE NOT NULL DEFAULT &#x27;<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    separated DATE NOT NULL DEFAULT &#x27;<span class="number">9999</span>-<span class="number">12</span>-<span class="number">31</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    job_code INT,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    store_id INT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> PARTITION BY LIST(store_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pNorth VALUES IN (<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">17</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pEast VALUES IN (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">20</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pWest VALUES IN (<span class="number">4</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">18</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pCentral VALUES IN (<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)；</span><br></pre></td></tr></table></figure>

<p>这使得在表中增加或删除指定地区的雇员记录变得容易起来。例如，假定西区的所有音像店都卖给了其他公司。那么与在西区音像店工作雇员相关的所有记录（行）可以使用查询“ALTER TABLE employees DROP PARTITION pWest；”来进行删除，它与具有同样作用的DELETE （删除）查询“DELETE query DELETE FROM employees WHERE store_id IN(4,12,13,14,18)；”比起来，要有效得多。</p>
<p>****要点：****如果试图插入列值不在分区值列表中的一行时，那么“INSERT”查询将失败并报错。例如，假定LIST分区的采用上面的方案，下面的插入将失败：</p>
<p>INSERT<code> </code>INTO<code>employees</code>VALUES<code>(</code>224<code>, </code>‘Linus’<code>, </code>‘Torvalds’<code>, </code>‘2002-05-01’<code>, </code>‘2004-10-12’<code>, </code>42<code>, </code>21<code>);</code></p>
<p>这是因为“store_id”列值21不能在用于定义分区pNorth, pEast, pWest,或pCentral的值列表中找到。要重点注意的是，LIST分区没有类似如“VALUES LESS THAN MAXVALUE”这样的包含其他值在内的定义。将要匹配的任何值都必须在值列表中找到。</p>
<p><em><strong>*3.HASH分区*</strong></em></p>
<p>这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。</p>
<p>hash分区的目的是将数据均匀的分布到预先定义的各个分区中，保证各分区的数据量大致一致。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MYSQL自动完成这些工作，用户所要定一个列值或者表达式，以及指定被分区的表将要被分割成的分区数量。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create <span class="selector-tag">table</span> t_hash( <span class="selector-tag">a</span> int(<span class="number">11</span>), <span class="selector-tag">b</span> datetime) partition by hash(year(<span class="selector-tag">b</span>)) partitions <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>hash的分区函数页需要返回一个整数值。partitions子句中的值是一个非负整数，不加的partitions子句的话，默认为分区数为1。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t_hash values(<span class="number">1</span>,&#x27;<span class="number">2010</span>-<span class="number">04</span>-<span class="number">01</span>&#x27;);</span><br></pre></td></tr></table></figure>

<p>该记录会被放入分区p2中。因为插入2010-04-01进入表t_hash,那么</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOD(YEAR(&#x27;<span class="number">2010</span>-<span class="number">04</span>-<span class="number">01</span>&#x27;),<span class="number">4</span>)=<span class="number">2</span></span><br><span class="line">mysql&gt; <span class="selector-tag">select</span> * <span class="selector-tag">from</span> information_schema<span class="selector-class">.partitions</span> where table_schema=&#x27;test2&#x27; and table_name=&#x27;t_hash&#x27;\<span class="selector-tag">G</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4.key分区</strong></p>
<p>key分区和hash分区相似，不同在于hash分区是用户自定义函数进行分区，key分区使用mysql数据库提供的函数进行分区，NDB cluster使用MD5函数来分区，对于其他存储引擎mysql使用内部的hash函数。</p>
<p>mysql&gt; create table t_key( a int(11), b datetime) partition by key(b)partitions 4;</p>
<p>上面的RANGE、LIST、HASH、KEY四种分区中，分区的条件必须是整形，如果不是整形需要通过函数将其转换为整形。</p>
<p><strong>5.columns分区</strong></p>
<p>mysql-5.5开始支持COLUMNS分区，可视为RANGE和LIST分区的进化，COLUMNS分区可以直接使用非整形数据进行分区。</p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="INNDB"><a href="#INNDB" class="headerlink" title="INNDB"></a>INNDB</h3><ul>
<li><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
</li>
<li><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制		             	  （MVCC）+ Next-Key Locking 防止幻影读。</p>
</li>
<li><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
</li>
<li><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入                     操作的插入缓冲区等。</p>
</li>
<li><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
</li>
</ul>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h3><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/23/mysql%E7%B4%A2%E5%BC%95/" data-id="clyxstfc7000344ut8n7y4c0p" data-title="mysql索引" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mysql高级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/23/mysql%E9%AB%98%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2022-07-23T01:56:22.000Z" itemprop="datePublished">2022-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/23/mysql%E9%AB%98%E7%BA%A7/">mysql高级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="mysql的逻辑结构"><a href="#mysql的逻辑结构" class="headerlink" title="mysql的逻辑结构"></a>mysql的逻辑结构</h3><p>从上到下：连接层、服务层、引擎层、存储层</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是mysql为了实现针对某个字段来进行快速查找的一种数据结构，其一般由以下几种数据结构组成</p>
<p>​	B+树，Hash，全文索引，空间数据索引，通过特定的算法，将数据与这些据索引上对应的位置进行关联，从而做到当我们需要查找某些数据的时候，不需要翻遍整张表，而只需要借助我们建立的索引就知道了。</p>
<h3 id="创建删除索引的语句"><a href="#创建删除索引的语句" class="headerlink" title="创建删除索引的语句"></a>创建删除索引的语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建索引</span><br><span class="line">	create index idx_name on t3(name);</span><br><span class="line">    alter table t3 add index idx_id(id);</span><br><span class="line">删除索引</span><br><span class="line">    drop index idx_id on t3;</span><br><span class="line">    alter table t3 drop primary key;</span><br></pre></td></tr></table></figure>

<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>普通索引</p>
<p>唯一索引</p>
<p>主键索引</p>
<p>组合索引</p>
<p>全文索引</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>大大减少了服务器需要扫描的数据行数</li>
<li>帮助服务器避免进行排序和分组</li>
<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>　创建索引和维护索引要耗费时间</li>
<li>　索引也需要占空间</li>
<li>　当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</li>
</ol>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动创建唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询与其他表关联的字段，外键关系应该创建索引</li>
<li>频繁更新的字段不适合创建索引</li>
<li>where条件里用不到的字段不要创建索引</li>
<li>查询中排序的字段，创建索引</li>
</ol>
<h1 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h1><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>通过explain可以分析得到表的读取顺序、数据读取的操作类型、哪些索引可以使用和哪些索引实际被使用，表之间的引用，每张表有多少行被查询。</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志就是记录在mysql中响应时间超过阈值的语句</p>
<h3 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h3><p>记录sql语句和其执行时间</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>​	<strong>全值匹配我最爱， 最左前缀要遵守；</strong></p>
<p>​	<strong>带头大哥不能死， 中间兄弟不能断；</strong></p>
<p>​	<strong>索引列上少计算， 范围之后全失效；</strong></p>
<p>​	*<em>LIKE 百分写最右， 覆盖索引不写 <em>；</em></em></p>
<p>​	<strong>不等空值还有 OR， 索引影响要注意；</strong></p>
<p>​	<strong>VARCHAR 引号不可丢， SQL 优化有诀窍。</strong></p>
<p>一定要用两个%的话，就要用覆盖索引</p>
<h3 id="语句优化"><a href="#语句优化" class="headerlink" title="语句优化"></a>语句优化</h3><ul>
<li><p>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的	   末 尾.HAVING最后。</p>
</li>
<li><p>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
</li>
<li><p>避免在索引列上使用计算</p>
</li>
<li><p>避免在索引列上使用IS NULL和IS NOT NULL</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>只返回必要的列：最好不要使用 SELECT * 语句。</p>
</li>
<li><p>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</p>
</li>
<li><p>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</p>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<ul>
<li>共享锁（读锁）：其他事务可以读，但不能写。</li>
<li>排他锁（写锁） ：其他事务不能读取，也不能写。</li>
</ul>
<p><strong>读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制?"></a>什么是主从复制?</h3><p>用来建立一个和主数据库完全一样的数据库环境，称为从数据库</p>
<h3 id="为什么要做主从（主从复制的作用）"><a href="#为什么要做主从（主从复制的作用）" class="headerlink" title="为什么要做主从（主从复制的作用）"></a>为什么要做主从（主从复制的作用）</h3><ol>
<li>作为备份，确保数据安全</li>
<li>读写分离，从服务器负责读，减少主服务器的压力</li>
<li>当主服务器出现问题，可以切换到从服务器，提高性能</li>
</ol>
<h3 id="主从复制的原理？"><a href="#主从复制的原理？" class="headerlink" title="主从复制的原理？"></a>主从复制的原理？</h3><ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<h1 id="mysql引擎"><a href="#mysql引擎" class="headerlink" title="mysql引擎"></a>mysql引擎</h1><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul>
<li>mysql默认使用</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。</li>
</ul>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><table>
<thead>
<tr>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>支持事务</td>
<td>不支事务</td>
</tr>
<tr>
<td>使用行锁（适合高并发）</td>
<td>使用表锁</td>
</tr>
<tr>
<td>支持外键</td>
<td>不支持外键</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/23/mysql%E9%AB%98%E7%BA%A7/" data-id="clyxstfc8000444ut7iarb0pa" data-title="mysql高级" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/23/java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-07-23T01:56:22.000Z" itemprop="datePublished">2021-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/23/java%E5%9F%BA%E7%A1%80/">java基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>byte&#x2F;8</li>
<li>char&#x2F;16</li>
<li>short&#x2F;16</li>
<li>int&#x2F;32</li>
<li>float&#x2F;32</li>
<li>long&#x2F;64</li>
<li>double&#x2F;64</li>
<li>boolean&#x2F;~  8</li>
</ul>
<p>euqals()除了string类是比较值以外，跟 &#x3D;&#x3D; 是一样的，比较两个引用是否引用同一对象，因为string类重写了equals方法</p>
<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<p>int和integer可以直接比较大小，因为有自动拆箱</p>
<h3 id="final和finally的区别"><a href="#final和finally的区别" class="headerlink" title="final和finally的区别"></a>final和finally的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final修饰的类是不能被继承的，因为其是一个最终类；</span><br><span class="line">final修饰的数据是一个常量，只能被赋值一次；</span><br><span class="line">final修饰的方法也不能重写，但能被重载；</span><br><span class="line">内部类只能访问被final修饰的局部变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">finally块通常放在try、catch的后面</span><br><span class="line">finally中的语句是正常执行或者处理异常之后必须执行的语句</span><br></pre></td></tr></table></figure>

<h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><strong>补充</strong>：String类内部数组定义为final类型，所以不可变，string类也被声明为final类型，所以不可被继承。</p>
<p>jdk1.8及以前String使用的是char数组，jdk1.9及以后使用的是byte数组。</p>
<p>因为开发人员发现人们使用的字符串值是拉丁字符居多而之前使用的char数组每一个char占用两个字节而拉丁字符只需要一个字节就可以存储，剩下的一个字节就浪费了，造成内存的浪费，gc的更加频繁。因此在jdk9中将String底层的实现改为了byte数组。</p>
<h4 id="StringBuffer与String的相互转换"><a href="#StringBuffer与String的相互转换" class="headerlink" title="StringBuffer与String的相互转换"></a><strong>StringBuffer与String的相互转换</strong></h4><p><strong>1、将StringBuffer转换成String</strong></p>
<p>1）toString()</p>
<p>2）String类中的构造函数     newString(buffer)</p>
<p><strong>2、将String转换成StringBuffer</strong></p>
<p>1）利用构造函数      new  StringBuffer(str)</p>
<p>2）调用append方法</p>
<h3 id="java有几种传参方式"><a href="#java有几种传参方式" class="headerlink" title="java有几种传参方式"></a>java有几种传参方式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q5706503/article/details/82910428?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">java的传参方式</a></p>
<p>只有<strong>值传递</strong>的方式，没有引用传递，<strong>基本数据类型</strong>在参数传递时并没有传进变量本身,</p>
<p>而是<strong>创建了一个新的相同数值的变量</strong>, 函数修改这个新变量并没有影响原来变量的数值,这也是<strong>按值传递的特点</strong></p>
<p><strong>那为什么对象a的数据就改变了呢?</strong></p>
<p>因为虽然也是按值传递, 复制了一份新的引用但是指向的对象是同一个,修改后会影响原对象</p>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类的类名和方法都要用absract修饰，抽象类不能被实例化，只能被继承，一个类包含抽象方法，这个类必须声明为抽象类。</p>
<p>jdk8以后，接口可以有静态方法和默认方法。接口用interface修饰，接口可以继承（继承多个接口），接口不能实例化</p>
<h3 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h3><p>封装：属性和方法封装到类的内部，通过对象来调用</p>
<p>继承：子类需要复用父类里面的属性或者方法</p>
<p>多态：父类引用指向子类实例</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/23/java%E5%9F%BA%E7%A1%80/" data-id="clyxstfc6000244ut13sf567p" data-title="java基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/23/JUC/">JUC</a>
          </li>
        
          <li>
            <a href="/2024/07/22/rabbitMq/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/07/22/redis%E6%95%99%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/23/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/2022/07/23/mysql%E7%B4%A2%E5%BC%95/">mysql索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>