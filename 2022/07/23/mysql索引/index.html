<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>mysql索引 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="mysql索引什么是索引？​	索引是mysql为了实现针对某个字段来进行快速查找的一种数据结构，其一般由以下几种数据结构组成 ​	B+树，Hash，全文索引，空间数据索引，通过特定的算法，将数据与这些据索引上对应的位置进行关联，从而做到当我们需要查找某些数据的时候，不需要翻遍整张表，而只需要借助我们建立的索引就知道了。 索引的优缺点优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql索引">
<meta property="og:url" content="http://example.com/2022/07/23/mysql%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="mysql索引什么是索引？​	索引是mysql为了实现针对某个字段来进行快速查找的一种数据结构，其一般由以下几种数据结构组成 ​	B+树，Hash，全文索引，空间数据索引，通过特定的算法，将数据与这些据索引上对应的位置进行关联，从而做到当我们需要查找某些数据的时候，不需要翻遍整张表，而只需要借助我们建立的索引就知道了。 索引的优缺点优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170920132504569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20170920132523536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg">
<meta property="article:published_time" content="2022-07-23T01:56:22.000Z">
<meta property="article:modified_time" content="2024-07-23T02:05:01.019Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-mysql索引" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/23/mysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="dt-published" datetime="2022-07-23T01:56:22.000Z" itemprop="datePublished">2022-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      mysql索引
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>​	索引是mysql为了实现针对某个字段来进行快速查找的一种数据结构，其一般由以下几种数据结构组成</p>
<p>​	B+树，Hash，全文索引，空间数据索引，通过特定的算法，将数据与这些据索引上对应的位置进行关联，从而做到当我们需要查找某些数据的时候，不需要翻遍整张表，而只需要借助我们建立的索引就知道了。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>　创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</li>
<li>　索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达	到上限值</li>
<li>　当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</li>
</ol>
<h2 id="索引使用的条件"><a href="#索引使用的条件" class="headerlink" title="索引使用的条件"></a>索引使用的条件</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用<strong>分区技术</strong>。</li>
</ul>
<h2 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h2><ul>
<li>对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，</li>
<li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li>
<li>在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li>
</ul>
<h2 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h2><ul>
<li><p><strong>单列索引</strong></p>
<p><strong>1.1.1、普通索引：</strong></p>
<p>​	MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p>
<p><strong>1.1.2、唯一索引：</strong></p>
<p>​	索引列中的值必须是唯一的，但是允许为空值，</p>
<p><strong>1.1.3、主键索引：</strong></p>
<p>​	是一种特殊的唯一索引，不允许有空值。</p>
</li>
<li><p><strong>组合索引</strong></p>
<p>​		在表中的多个字段组合上创建的索引，只有在<strong>查询条件中使用了这些字段的左边字段时</strong>，索引才会被使用，使用组合索引时遵循<strong>最左前缀集合</strong>。这个如果还不明白，等后面举例讲解时在细说</p>
</li>
<li><p><strong>全文索引</strong></p>
<p>​		全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个大煞笔，二货 …” 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。</p>
</li>
<li><p><strong>空间索引</strong></p>
<p>​		空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。</p>
</li>
</ul>
<h2 id="常用操作语句"><a href="#常用操作语句" class="headerlink" title="常用操作语句"></a>常用操作语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">普通索引INDEX：加速查找</span><br><span class="line">    唯一索引：</span><br><span class="line">        -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）</span><br><span class="line">        -唯一索引UNIQUE:加速查找+约束（不能重复）</span><br><span class="line">    联合索引：</span><br><span class="line">        -PRIMARY KEY(id,name):联合主键索引</span><br><span class="line">        -UNIQUE(id,name):联合唯一索引</span><br><span class="line">        -INDEX(id,name):联合普通索引</span><br><span class="line">1. 创建表的时候指定索引</span><br><span class="line">    create table t1(</span><br><span class="line">    id int primary key, # primary key 默认自带索引</span><br><span class="line">    name char(10),</span><br><span class="line">    unique key(name),</span><br><span class="line">    )</span><br><span class="line">2. 创建表后再为其加上索引</span><br><span class="line">    create table t2（</span><br><span class="line">    id int，</span><br><span class="line">    name char(5)</span><br><span class="line">    ）;</span><br><span class="line"></span><br><span class="line">    create index idx_name on t3(name);</span><br><span class="line">    alter table t3 add index idx_id(id);</span><br><span class="line">3. 删除索引</span><br><span class="line">    drop index idx_id on t3;</span><br><span class="line">    alter table t3 drop primary key;</span><br></pre></td></tr></table></figure>

<h2 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>数据结构</strong> </p>
<p>​		B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img"></p>
<p><strong>查找过程</strong></p>
<ul>
<li>​		进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针</li>
<li>​		然后递归地在指针所指向的节点进行查找。直到查找到叶子节点</li>
<li>​		然后在叶子节点上进行二分查找，找出 key 所对应的 data。</li>
<li>​		插入删除操作会破坏<strong>平衡树的平衡性</strong>，因此在进行插入删除操作之后，需要对树进行<strong>分裂、合并、旋转等操作来维护平衡性</strong>。</li>
</ul>
<h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><p><strong>B树</strong></p>
<p> 每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。</p>
<p> <img src="https://img-blog.csdn.net/20170920132504569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>B+树</strong></p>
<p> 只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。</p>
<p> <img src="https://img-blog.csdn.net/20170920132523536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>后来，在B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的        首选数据结构。 </p>
<h4 id="为什么使用B-树来作为索引的底层？"><a href="#为什么使用B-树来作为索引的底层？" class="headerlink" title="为什么使用B+树来作为索引的底层？"></a>为什么使用B+树来作为索引的底层？</h4><p>​		一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I&#x2F;O消耗，相对于内存存取，I&#x2F;O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的时间复杂度。树高度越小，I&#x2F;O次数越少。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li><p>无法用于排序与分组；</p>
</li>
<li><p>只支持精确查找，无法用于部分查找和范围查找。</p>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree</p>
</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p><strong>1. where语句中包含or时，可能会导致索引失效</strong></p>
<p>使用or并不是一定会使索引失效，你需要看or左右两边的查询列是否命中相同的索引。</p>
<p>假设USER表中的user_id列有索引，age列没有索引。</p>
<p>下面这条语句其实是命中索引的（据说是新版本的MySQL才可以，如果你使用的是老版本的MySQL，可以使用explain验证下）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> user_id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>但是这条语句是无法命中索引的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>假设age列也有索引的话，依然是无法命中索引的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>因此才有建议说，尽量避免使用or语句，可以根据情况尽量使用union all或者in来代替，这两个语句的执行效率也比or好些。</p>
<p><strong>2. where语句中索引列使用了负向查询，可能会导致索引失效</strong></p>
<p>​	负向查询包括：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</p>
<p><strong>3. 索引字段可以为null，使用is null或is not null时，可能会导致索引失效</strong></p>
<p>​	和or类似，如果是命中同一个索引是有效的，当时如果命中的补水同一个索引的话就会失效</p>
<p><strong>4. 在索引列上使用内置函数，一定会导致索引失效</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> DATE_ADD(login_time, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="operator">=</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p><strong>5.联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效</strong></p>
<p><strong>6. like通配符可能会导致索引失效</strong></p>
<p>like查询以%开头时，会导致索引失效</p>
<p>将%移到后面，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;李%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>利用覆盖索引来命中索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;%李%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>7.MySQL优化器的最终选择，不走索引</strong></p>
<p>​		如果引擎的出一个结论，即不需要索引，此时索引也会失效</p>
<p><strong>8 包含隐式的类型转化时也会出现索引失效的后果</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> name<span class="operator">=</span><span class="number">123</span></span><br><span class="line">优化</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>9. 对索引列进行运算，一定会导致索引失效</strong></p>
<p>运算如+，-，*，&#x2F;等，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> age <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>优化的话，要把运算放在值上，或者在应用程序中直接算好，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">user</span>` <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span> <span class="operator">-</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>





<p>索引覆盖和回表  </p>
<h2 id="聚簇索引的注意点有哪些？"><a href="#聚簇索引的注意点有哪些？" class="headerlink" title="聚簇索引的注意点有哪些？"></a><strong>聚簇索引的注意点有哪些？</strong></h2><p>聚簇索引表最大限度地提高了 I&#x2F;O 密集型应用的性能，但它也有以下几个限制：</p>
<ul>
<li><p>1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
<blockquote>
<p>关于这一点，可能面试官会换一个问法。例如，为什么主键需要是自增 ID ，又或者为什么主键需要带有时间性关联。</p>
</blockquote>
</li>
<li><p>2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。</p>
<blockquote>
<p>MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。</p>
</blockquote>
</li>
<li><p>3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<blockquote>
<p>当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
</blockquote>
</li>
<li><p>4、主键 ID 建议使用整型。因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。</p>
</li>
</ul>
<h1 id="msql优化"><a href="#msql优化" class="headerlink" title="msql优化"></a>msql优化</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>慢查询日志就是记录在mysql中响应时间超过阈值的语句</p>
<h2 id="mysql的瓶颈"><a href="#mysql的瓶颈" class="headerlink" title="mysql的瓶颈"></a>mysql的瓶颈</h2><ol>
<li>CPU 瓶颈：CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候</li>
<li>IO 瓶颈：磁盘I&#x2F;O瓶颈发生在装入数据远大于内存容量时</li>
<li>服务器硬件的性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态</li>
</ol>
<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><strong>作用</strong></p>
<p>​		使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈</p>
<p><strong>字段含义</strong></p>
<ol>
<li>表的读取顺序（id 字段）    <strong>id值越大优先级越高，越先被执行</strong></li>
<li>数据读取操作的操作类型（select_type 字段）</li>
<li>哪些索引可以使用（possible_keys 字段）</li>
<li>哪些索引被实际使用（keys 字段）</li>
<li>表之间的引用（ref 字段）</li>
<li>每张表有多少行被优化器查询（rows 字段）</li>
</ol>
<h2 id="优化顺序"><a href="#优化顺序" class="headerlink" title="优化顺序"></a>优化顺序</h2><ul>
<li><p>SQL语句及索引的优化</p>
</li>
<li><p>数据库表结构的优化</p>
</li>
<li><p>系统配置的优化</p>
</li>
<li><p>硬件的优化</p>
</li>
</ul>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>​	<strong>全值匹配我最爱， 最左前缀要遵守；</strong></p>
<p>​	<strong>带头大哥不能死， 中间兄弟不能断；</strong></p>
<p>​	<strong>索引列上少计算， 范围之后全失效；</strong></p>
<p>​	*<em>LIKE 百分写最右， 覆盖索引不写 <em>；</em></em></p>
<p>​	<strong>不等空值还有 OR， 索引影响要注意；</strong></p>
<p>​	<strong>VARCHAR 引号不可丢， SQL 优化有诀窍。</strong></p>
<p>一定要用两个%的话，就要用覆盖索引</p>
<h2 id="语句优化"><a href="#语句优化" class="headerlink" title="语句优化"></a>语句优化</h2><ul>
<li><p>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的	   末 尾.HAVING最后。</p>
</li>
<li><p>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
</li>
<li><p>避免在索引列上使用计算</p>
</li>
<li><p>避免在索引列上使用IS NULL和IS NOT NULL</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>只返回必要的列：最好不要使用 SELECT * 语句。</p>
</li>
<li><p>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</p>
</li>
<li><p>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</p>
</li>
</ul>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="S锁"><a href="#S锁" class="headerlink" title="S锁"></a>S锁</h3><p>如果事务T1持有了行r上的<code>S锁</code>，则其他事务可以同时持有行r的<code>S锁</code>，但是不能对行r加<code>X锁</code>。</p>
<h3 id="X锁"><a href="#X锁" class="headerlink" title="X锁"></a>X锁</h3><p>如果事务T1持有了行r上的<code>X锁</code>，则其他任何事务不能持有行r的<code>X锁</code>，必须等待T1在行r上的<code>X锁</code>释放。</p>
<p>如果事务T1在行r上保持<code>S锁</code>，则另一个事务T2对行r的锁的请求按如下方式处理：</p>
<ul>
<li>T2可以同时持有S锁</li>
<li>T2如果想在行r上获取<code>X锁</code>，必须等待其他事务对该行添加的<code>S锁</code>或<code>X锁</code>的释放。</li>
</ul>
<h3 id="锁的兼容性"><a href="#锁的兼容性" class="headerlink" title="锁的兼容性"></a>锁的兼容性</h3><p>锁的兼容矩阵如下：</p>
<table>
<thead>
<tr>
<th align="left">—</th>
<th align="center">排它锁(X)</th>
<th align="center">意向排它锁(IX)</th>
<th align="center">共享锁(S)</th>
<th align="center">意向共享锁(IS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">排它锁(X)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="left">意向排它锁(IX)</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">N</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="left">共享锁(S)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="left">意向共享锁(IS)</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">OK</td>
<td align="center">OK</td>
</tr>
</tbody></table>
<p>意向锁的主要目的是显示事务正在锁定某行或者正意图锁定某行</p>
<p><strong>当前读</strong></p>
<p>​		当前读，又叫加锁读，或者 阻塞读。这种读取操作不再是读取快照，而是读取最新版本并且加锁。<br>快照读不会添加任何锁。</p>
<p>这种情况下，引入我们常见的两种方式来解决该问题</p>
<ul>
<li><em><strong>乐观锁</strong></em>：在<code>UPDATE</code>的<code>WHERE</code>子句中加入版本号信息来确定修改是否生效</li>
<li><em><strong>悲观锁</strong></em>：在<code>UPDATE</code>执行前，<code>SELECT</code>后面加上<code>FOR UPDATE</code>来给记录加锁，保证记录在<code>UPDATE</code>前不被修改。<code>SELECT ... FOR UPDATE</code>是加上了X锁，也可以通过<code>SELECT ... LOCK IN SHARE MODE</code>加上S锁，来防止其他事务对该行的修改。</li>
</ul>
<p>无论是乐观锁还是悲观锁，<strong>使用的思想都是一致的，那就是当前读</strong>。乐观锁利用<code>当前读</code>判断是否是最新版本，悲观锁利用<code>当前读</code>锁定行。<br>但是使用乐观锁时仍然需要非常谨慎，因为RR是可重复读的，一定不能在UPDATE之前先把版本号读取出来。</p>
<h2 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>​		<strong>分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，每个表都对应三个文件，MYD数据文件，.MYI索引文件，.frm表结构文件。app读写的时候根据事先定义好的规则得到对应的表名，然后去操作它。</strong></p>
<hr>
<p><strong>垂直切分</strong></p>
<p>​		垂直切分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></p>
<ul>
<li>​		<strong>把不常用的字段单独放在一张表</strong></li>
<li>​		<strong>把text，blob（binary large object，二进制大对象）等大字段拆分出来放在附表中;</strong></li>
<li>​		<strong>经常组合查询的列放在一张表中;</strong></li>
</ul>
<p><strong>水平拆分</strong></p>
<p>​		水平切分就是指把数据库的行进行切分，分解成多个不同的表</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></p>
<ul>
<li><p><strong>通过hash来分表</strong></p>
</li>
<li><p><strong>通过取模来分表</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>1.分布式事务问题</strong><br>做了垂直分库或者水平分库以后,就必然会涉及到跨库执行SQL的问题,就会引发互联网界的老大难问题-“分布式事务”。那么要如何解决这个问题呢？<br>使用分布式事务中间件<br>使用MySQL自带的针对跨库的事务一致性方案(XA),不过性能要比单库的慢10倍左右。<br>能否避免掉跨库操作(比如将用户和商品放在同一个库中)<br><strong>2.跨库join的问题</strong><br>    分库分表后，表之间的关联操作将受到限制，就无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。<br>那么要如何解决这个问题呢？<br>简单的解决方法：<br>全局表：基础数据，所有库都拷贝一份。<br>字段冗余：把需要join的字段冗余在各个表中，这样有些字段就不用join去查询了。<br>系统层组装：应用端先分别查询出所有复核条件的，然后在应用端组装起来，类似于一个mapreduce的过程（较复杂）。<br><strong>3.横向扩容的问题</strong><br>    当我们使用哈希取模做分表的时候,针对数据量的递增,可能需要动态的增加表,此时就需要考虑数据迁移的问题。<br>原来使用的是hash后对8进行取模，那么，数据是均分在8个表(库)上。<br>如果8个表不够的时候，我们要扩展到16个表，这时候，我们hash后对16取模，新数据是没有问题的，旧数据就会发生错乱。<br>如果哈希后是9，那么，原来我们对8取模后，是1，会到表1进行查询；但是，现在我们是对16取模，那么是到表9进行查询的，而这个数据在表9又不存在，因此，就会找不到数据了<br><strong>4.结果集合并、排序的问题</strong><br>    因为我们是将数据分散存储到不同的库、表里的,当我们查询指定数据列表时,数据来源于不同的子库或者子表,就必然会引发结果集合并、排序的问题。<br>如果每次查询都需要排序、合并等操作,性能肯定会受非常大的影响。</p>
</li>
</ul>
<h3 id="分区（partition）"><a href="#分区（partition）" class="headerlink" title="分区（partition）"></a>分区（partition）</h3><p>​		分区和分表相似，都是按照规则分解表。不同在于分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，分区后，表还是一张表，但数据散列到多个位置了。app读写的时候操作的还是表名字，db自动去组织分区的数据。</p>
<p><strong>水平分区</strong></p>
<p>​		水平分区（Horizontal Partitioning） 这种形式分区是对表的行进行分区，所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</p>
<p>​		举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。		</p>
<p><strong>垂直分区</strong></p>
<p>​		垂直分区（Vertical Partitioning）这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p>
<p>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p>
<p>分区的方式</p>
<p><em><strong>*1.RANGE分区*</strong></em></p>
<p>基于属于一个给定连续区间的列值，把多行分配给分区。这些区间要连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。以下是实例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">CREATE <span class="selector-tag">TABLE</span> employees (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id INT NOT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hired DATE NOT NULL DEFAULT &#x27;<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    separated DATE NOT NULL DEFAULT &#x27;<span class="number">9999</span>-<span class="number">12</span>-<span class="number">31</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    job_code INT NOT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    store_id INT NOT NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> partition BY RANGE (store_id) (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p0 VALUES LESS THAN (<span class="number">6</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p1 VALUES LESS THAN (<span class="number">11</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p2 VALUES LESS THAN (<span class="number">16</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    partition p3 VALUES LESS THAN (<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>按照这种分区方案，在商店1到5工作的雇员相对应的所有行被保存在分区P0中，商店6到10的雇员保存在P1中，依次类推。注意，每个分区都是按顺序进行定义，从最低到最高。<br>对于包含数据(72, ‘Michael’, ‘Widenius’, ‘1998-06-25’, NULL, 13)的一个新行，可以很容易地确定它将插入到p2分区中，但是如果增加了一个编号为第21的商店，将会发生什么呢？在这种方案下，由于没有规则把store_id大于20的商店包含在内，服务器将不知道把该行保存在何处，将会导致错误。要避免这种错误，可以创建maxvalue分区，所有不在指定范围内的记录都会被存储到maxvalue所在的分区中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter <span class="selector-tag">table</span> test2<span class="selector-class">.user</span> add partition (partition p4 values less than maxvalue);</span><br></pre></td></tr></table></figure>

<p><em><strong>*2.LIST分区*</strong></em></p>
<p>类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。<br> LIST分区通过使用“PARTITION BY LIST(expr)”来实现，其中“expr” 是某列值或一个基于某个列值、并返回一个整数值的表达式，然后通过“VALUES IN (value_list)”的方式来定义每个分区，其中“value_list”是一个通过逗号分隔的整数列表。要按照属于同一个地区商店的行保存在同一个分区中的方式来分割表，可以使用下面的“CREATE TABLE”语句：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">CREATE <span class="selector-tag">TABLE</span> employees (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id INT NOT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lname VARCHAR(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hired DATE NOT NULL DEFAULT &#x27;<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    separated DATE NOT NULL DEFAULT &#x27;<span class="number">9999</span>-<span class="number">12</span>-<span class="number">31</span>&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    job_code INT,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    store_id INT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> PARTITION BY LIST(store_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pNorth VALUES IN (<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">17</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pEast VALUES IN (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">20</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pWest VALUES IN (<span class="number">4</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">18</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PARTITION pCentral VALUES IN (<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)；</span><br></pre></td></tr></table></figure>

<p>这使得在表中增加或删除指定地区的雇员记录变得容易起来。例如，假定西区的所有音像店都卖给了其他公司。那么与在西区音像店工作雇员相关的所有记录（行）可以使用查询“ALTER TABLE employees DROP PARTITION pWest；”来进行删除，它与具有同样作用的DELETE （删除）查询“DELETE query DELETE FROM employees WHERE store_id IN(4,12,13,14,18)；”比起来，要有效得多。</p>
<p>****要点：****如果试图插入列值不在分区值列表中的一行时，那么“INSERT”查询将失败并报错。例如，假定LIST分区的采用上面的方案，下面的插入将失败：</p>
<p>INSERT<code> </code>INTO<code>employees</code>VALUES<code>(</code>224<code>, </code>‘Linus’<code>, </code>‘Torvalds’<code>, </code>‘2002-05-01’<code>, </code>‘2004-10-12’<code>, </code>42<code>, </code>21<code>);</code></p>
<p>这是因为“store_id”列值21不能在用于定义分区pNorth, pEast, pWest,或pCentral的值列表中找到。要重点注意的是，LIST分区没有类似如“VALUES LESS THAN MAXVALUE”这样的包含其他值在内的定义。将要匹配的任何值都必须在值列表中找到。</p>
<p><em><strong>*3.HASH分区*</strong></em></p>
<p>这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。</p>
<p>hash分区的目的是将数据均匀的分布到预先定义的各个分区中，保证各分区的数据量大致一致。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MYSQL自动完成这些工作，用户所要定一个列值或者表达式，以及指定被分区的表将要被分割成的分区数量。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create <span class="selector-tag">table</span> t_hash( <span class="selector-tag">a</span> int(<span class="number">11</span>), <span class="selector-tag">b</span> datetime) partition by hash(year(<span class="selector-tag">b</span>)) partitions <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>hash的分区函数页需要返回一个整数值。partitions子句中的值是一个非负整数，不加的partitions子句的话，默认为分区数为1。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t_hash values(<span class="number">1</span>,&#x27;<span class="number">2010</span>-<span class="number">04</span>-<span class="number">01</span>&#x27;);</span><br></pre></td></tr></table></figure>

<p>该记录会被放入分区p2中。因为插入2010-04-01进入表t_hash,那么</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOD(YEAR(&#x27;<span class="number">2010</span>-<span class="number">04</span>-<span class="number">01</span>&#x27;),<span class="number">4</span>)=<span class="number">2</span></span><br><span class="line">mysql&gt; <span class="selector-tag">select</span> * <span class="selector-tag">from</span> information_schema<span class="selector-class">.partitions</span> where table_schema=&#x27;test2&#x27; and table_name=&#x27;t_hash&#x27;\<span class="selector-tag">G</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4.key分区</strong></p>
<p>key分区和hash分区相似，不同在于hash分区是用户自定义函数进行分区，key分区使用mysql数据库提供的函数进行分区，NDB cluster使用MD5函数来分区，对于其他存储引擎mysql使用内部的hash函数。</p>
<p>mysql&gt; create table t_key( a int(11), b datetime) partition by key(b)partitions 4;</p>
<p>上面的RANGE、LIST、HASH、KEY四种分区中，分区的条件必须是整形，如果不是整形需要通过函数将其转换为整形。</p>
<p><strong>5.columns分区</strong></p>
<p>mysql-5.5开始支持COLUMNS分区，可视为RANGE和LIST分区的进化，COLUMNS分区可以直接使用非整形数据进行分区。</p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="INNDB"><a href="#INNDB" class="headerlink" title="INNDB"></a>INNDB</h3><ul>
<li><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
</li>
<li><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制		             	  （MVCC）+ Next-Key Locking 防止幻影读。</p>
</li>
<li><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
</li>
<li><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入                     操作的插入缓冲区等。</p>
</li>
<li><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
</li>
</ul>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h3><ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/23/mysql%E7%B4%A2%E5%BC%95/" data-id="clyxstfc7000344ut8n7y4c0p" data-title="mysql索引" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/23/JVM/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JVM
        
      </div>
    </a>
  
  
    <a href="/2022/07/23/mysql%E9%AB%98%E7%BA%A7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">mysql高级</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/23/JUC/">JUC</a>
          </li>
        
          <li>
            <a href="/2024/07/22/rabbitMq/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/07/22/redis%E6%95%99%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/23/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/2022/07/23/mysql%E7%B4%A2%E5%BC%95/">mysql索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>